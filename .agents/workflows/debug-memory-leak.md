---
description: 디버깅, 메모리 누수 탐지 및 보안 강화를 위한 글로벌 통합 워크플로우
---

# 글로벌 통합 디버깅, 메모리 누수 파악 및 보안 워크플로우

이 워크플로우는 소프트웨어의 신뢰성, 성능, 그리고 보안을 보장하기 위한 가장 기본적이며 필수적인 절차입니다.
어떤 언어나 환경(C++, C#, Python, Delphi 등)에서도 적용될 수 있는 보편적인 접근 방식을 제공합니다.

## Phase 1: 디버깅 및 에러 추적 (재현과 로깅)

디버깅의 가장 첫 번째 단계는 "추측하지 않고 증명하는 것"입니다.

- **증상 스크랩:**
  문제가 발생하는 정확한 조건(OS, 컴파일러 버전, 사용자의 입력)을 기록합니다.
- **최소 재현 가능 예제 (MinRepro) 작성:**
  버그가 발생하는 가장 작고 독립적인 코드를 분리합니다.
- **로깅 활성화 및 분석:**
  에러를 삼키는 빈 `catch`나 `except` 블록이 있다면 즉시 구조적 로깅 코드로 대체합니다. 
  모든 외부 시스템 경계 지점 (네트워크, 파일 읽기/쓰기, DB 쿼리)에 로그를 추가합니다.
- **Fail-Fast 검증:**
  함수 진입점 등에서 인자의 유효성을 검사하는 Guard Clause를 추가하여, 문제가 발생하기 전 최대한 빨리 실패하도록 유도합니다.

## Phase 2: 메모리 누수 및 리소스 관리

자원 관리의 원칙은 "할당한 자가 책임지고 해제한다"입니다.

- **할당-해제 매칭 검증:**
  가비지 컬렉터(GC) 환경이 아닌 코드(C/C++, Delphi 등)에서는 `new/delete`, `malloc/free`, `Create/Free` 쌍이 제대로 맺어졌는지 확인합니다. 파일 핸들 및 네트워크 소켓 등이 닫혔는지 검수합니다.
- **정적/동적 분석 도구 실행:**
  - **C/C++:** Valgrind(Linux) 또는 Visual Studio Diagnostic Tools(Windows), AddressSanitizer (ASan) 적용 시도.
  - **.NET:** dotMemory, Visual Studio 프로파일러.
  - **Delphi:** FastMM4 리크 리포팅 켜기, ReportMemoryLeaksOnShutdown := True 설정.
- **생명주기(Lifecycle) 점검:**
  이벤트 리스너, 델리게이트, 옵저버 패턴 사용 시 구독 해지가 명확하게 이루어지고 있는지 확인합니다.

## Phase 3: 보안 및 안전성 강화 (Zero Trust)

설계의 경계를 넘어오는 데이터는 잠재적인 공격 벡터로 취약합니다.

- **입력 데이터 검증 (Input Validation):**
  외부에서 들어오는 모든 입력은 절대로 신뢰하지 않으며 엄격한 화이트리스트 검사, 타입 체크 및 길이 제한을 수행합니다. String interpolation이나 연결(concatenation)을 사용한 SQL 쿼리 생성을 Prepared Statement 패턴으로 수정합니다.
- **메모리 안전성 확보:**
  C/C++ 또는 Rust Unsafe 블록 내부의 포인터 연산을 최소화하거나 스마트 포인터 연산(`std::unique_ptr`, `std::shared_ptr`) 및 RAII 패턴을 적용하여 잘못된 포인터 참조나 버퍼 오버플로우를 차단합니다.
- **최소 권한의 원칙 (Least Privilege):**
  프로그램이나 스크립트 실행에 필요한 권한을 확인하여, 관리자 권한(UAC) 같은 민감한 권한이 반드시 필요한 곳에만 국한되게 합니다.
- **비밀 정보 보호 (Secret Management):**
  소스 코드에 하드코딩된 API Key, 비밀번호 등을 탐색하고 환경 변수나 보안 볼트(Vault)에서 런타임에 로드하도록 수정합니다.

## Phase 4: 리뷰 및 회고

- [ ] 버그 수정 및 보안 강화 후, 기존 로직이나 성능에 부작용(Side Effect)이 있는지 관련 테스트 케이스를 실행합니다.
- [ ] 적용된 수정 사항을 문서화하고, 코드 리뷰 및 CI/CD 환경에 정적 분석 패스를 추가 연동합니다.
